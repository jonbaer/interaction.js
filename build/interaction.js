/* This file is automatically generated */

/*

Copyright (c) 2008 Rizqi Ahmad

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. 

*/

/* core.js */
(function($){

$.Interaction = 
{
	services: {},
	
	add: function(name, proto)
	{
		var services = $.Interaction.services;
		
		services[name] = $.extend({}, this.base, proto);
		
		$.fn[name] = function(options)
		{
			var service = this.data('interaction-'+name);
		
			if(typeof options != 'string')
			{
				if(service)
					service.$destroy();
			
				this.data('interaction-'+name, $.extend({element:this, name:name}, services[name]));
				service = this.data('interaction-'+name);
				service.init(options);
				
				return this;
			}
		
			else
			{
				var command = options;
				options = Array.prototype.slice.call(arguments, 1);
				
				if(command == '?')
					return !!service;
				else if(service && typeof service['$'+command] == 'function')
					return service['$'+command].apply(service, options);
				else
					return services[name]['$'+command].apply({isEnabled:false, dummy:true}, options);
			}
		}
	},
	
	extend: function(name, proto)
	{
		if(this.services[name])
			this.services[name] = $.extend(this.services[name], proto);
	},
	
	listeners: {},
	
	listen: function(service, name, fn)
	{
		if(!this.listeners[service])
			this.listeners[service] = {};
		
		var obj = {};
		
		if(typeof name == 'string')
			obj[name] = fn;
		else if(typeof name == 'object')
			obj = name;
		
		for(var n in obj)
		{
			if(!this.listeners[service][n])
				this.listeners[service][n] = [];
			
			this.listeners[service][n].push(obj[n]);
		}
	},
	
	defaults: function(service, defaults)
	{
		if(this.services[service])
			$.extend(this.services[service].defaults, defaults);
	}
};

$.Interaction.base =
{
	init: function()
	{
		this.base();
	},

	base: function()
	{
		this.setting = $.extend({}, (typeof this.defaults == 'function') ? this.defaults() : this.defaults || {});
		this.functionWrappers = [];
		this.temp = {};
		this.isEnabled = true;
		
		this.listeners = {};
		var listeners = $.Interaction.listeners[this.name] || {};
		for(var i in listeners)
			this.listeners[i] = [].concat(listeners[i]);
	
		this.element.addClass('interaction-'+this.name);
		var self = this;
		this.element.chain('plugin', this.name, function(){
			self.builder($(this));
		});
	},

	wrap: function(fn)
	{
		var self = this;
		var args = Array.prototype.slice.call(arguments, 1);
		var array = this.functionWrappers;
		var wrap;
	
		if(typeof fn == 'string')
			fn = self[fn];
	
		for(var i=0; i<array.length; i++)
		{	
			if(array[i].src == fn)
			{
				wrap = array[i];
				break;
			}
		}
	
		if(!wrap)
		{
			wrap = {src:fn, fn:function(){
				return fn.apply(self, Array.prototype.slice.call(arguments).concat(args));
			}};
			array.push(wrap);
		}
	
		return wrap.fn;
	},

	builder: function(item)
	{
	
	},
	
	addListener: function(name, fn)
	{
		if(!this.listeners[name])
			this.listeners[name] = [];
		
		this.listeners[name].push(fn);
	},
	
	removeListener: function(name, fn)
	{
		if(!this.listeners[name])
			this.listeners[name] = [];
		
		if(fn)
		{
			var res = [];
			for(var i=0; i<this.listeners[name].length; i++)
				if(this.listeners[name][i] != fn)
					res.push(this.listeners[name][i]);
			this.listeners[name] = res;
		}
		else
		{
			this.listeners[name] = [];
		}
	},
	
	extractListener: function()
	{
		for(var i=0; i<arguments.length; i++)
		{
			if(this.setting[arguments[i]])
				this.addListener('$'+arguments[i], this.setting[arguments[i]]);
		}
	},
	
	callListener: function(name)
	{
		if(!this.listeners[name])
			this.listeners[name] = [];
			
		if(!this.listeners['$'+name])
			this.listeners['$'+name] = [];
		
		var args = Array.prototype.slice.call(arguments, 1);
		
		for(var i=0; i<this.listeners[name].length; i++)
			this.listeners[name][i].apply(this, args);
			
		for(var i=0; i<this.listeners['$'+name].length; i++)
			this.listeners['$'+name][i].apply(this.element, [this].concat(args));
	},

	destroy: function()
	{
		this.element.unbind('.'+this.name);
		this.element.removeData('interaction-'+this.name);
		this.element.removeClass('interaction-'+this.name);
	
		this.element.chain('plugin', this.name, null);
	
		this.element.getItemEl().each(function(){
			$(this).unbind('.'+this.name+'-item');
		});
		
		this.callListener('destroy');
	},
	
	$listen: function(name, fn)
	{
		if(this.dummy) return this.element;
		
		var obj = {};
		
		if(typeof name == 'string')
			obj[name] = fn;
		else if(typeof name == 'object')
			obj = name;
		
		for(var n in obj)
			this.addListener('$'+n, obj[n]);
		
		return this.element;
	},
	
	$unlisten: function(name, fn)
	{
		if(this.dummy) return this.element;
		
		this.removeListener('$'+name, fn);
		
		return this.element;
	},
	
	$service: function()
	{
		return this.dummy ? null : this;
	},

	$destroy: function()
	{
		if(!this.dummy)
			this.destroy();
		
		return this.element;
	},
	
	
	$enable: function()
	{
		if(this.dummy) return this.element;
		
		this.isEnabled = true;
		this.callListener('enable');
		
		return this.element;
	},
	
	$disable: function()
	{
		if(this.dummy) return this.element;
		
		if(this.mouseUp)
			this.mouseUp(this.mouseDownEvent);
		this.isEnabled = false;
		this.callListener('disable');
		
		return this.element;
	}
};

// Adaptation of ui.mouse (c) Paul Bakaus
$.Interaction.mouse =
{
	mouseDown: function(event)
	{
		var self = this;
		if(this.isMouseStarted)
			this.mouseUp(event);
	
		this.mouseDownEvent = event;
		
		var cancel = (typeof this.setting.cancel == 'string'
			&& $(event.target).parents().add(event.target).filter(this.setting.cancel).length);
	
		if(event.which != 1 || this.mouseCapture(event) || cancel)
			return false;
	
		this.isMouseDelayMet = false;
		setTimeout(function(){self.isMouseDelayMet = true;}, this.setting.delay);
	
		if(event.preventDefault)
			event.preventDefault();
		
		if($.browser.msie)
			document.onselectstart = function(){return false};
	
		$(document)
			.bind('mousemove.'+this.name, this.wrap('mouseMove'))
			.bind('mouseup.'+this.name, this.wrap('mouseUp'));
	
		return true;
	},

	mouseMove: function(event)
	{
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.browser.msie && !event.button)
		{
			this.mouseUp(event);
			return false;
		}
		
		this.mouseMoveEvent = event;
	
		if(this.isMouseStarted)
		{
			this.mouseDrag(event);
		}
		else if(this.mouseDistanceMet(event) && this.mouseDelayMet(event))
		{
			this.isMouseStarted = this.mouseStart(event);
			if(this.isMouseStarted)
				this.mouseDrag(event);
			else
				this.mouseUp(event);
		}
	
		return this.isMouseStarted;
	},

	mouseUp: function(event)
	{
		$(document)
			.unbind('mousemove.'+this.name, this.wrap('mouseMove'))
			.unbind('mouseup.'+this.name, this.wrap('mouseUp'));
		
		if($.browser.msie)
			document.onselectstart = function(){return true;};
	
		if(this.isMouseStarted)
		{
			this.isMouseStarted = false;
			this.mouseStop(event);
		}
	},

	mouseDistanceMet: function(e) {
		return (Math.max(
				Math.abs(this.mouseDownEvent.pageX - e.pageX),
				Math.abs(this.mouseDownEvent.pageY - e.pageY)
			) >= this.setting.distance
		);
	},

	mouseDelayMet: function(e) {
		return this.isMouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	mouseStart: function() {return false;},
	mouseDrag: function() {return false;},
	mouseStop: function() {return false;},
	mouseCapture: function() {return false;}
};

})(jQuery);


/* draggable.js */
(function($){
	
$.Interaction.add('draggable', $.extend({}, $.Interaction.mouse, {
	defaults: 
	{
		helper: function(e){return $(e).clone();},
		handle: null,
		classPrefix: 'drag-',
		container: null,
		cancel: ':input',
		cursorAt: null,
		axis: 'xy',
		delay: 0,
		distance: 0
	},
	
	init: function(setting)
	{
		this.base();
		$.extend(this.setting, setting);
		if(!$('#interaction-draggable-container').length)
			$('<div>')
				.attr('id', 'interaction-draggable-container')
				.css('position', 'absolute')
				.hide()
				.appendTo(document.body);
		
		this.container = $(this.setting.container || '#interaction-draggable-container');
		
		this.cursor = null;
		this.position = {x:0, y:0};
		
		this.extractListener('start', 'drag', 'stop');
		
		this.callListener('init');
	},
	
	builder: function(item)
	{
		var self = this;
		
		this.getHandle(item).bind('mousedown.draggable-item', function(event){
			if(self.isEnabled)
			{
				self.item = item;
				self.mouseDown(event);
			}
		});
		
		this.callListener('build', item);
	},
	
	mouseStart: function(event)
	{
		if(!this.item || !this.item.length)
			return this.mouseUp(event);
		
		if(!this.cursor)
		{
			this.cursor = {};
			if(this.setting.cursorAt)
			{
				this.cursor.left = this.setting.cursorAt.left;
				this.cursor.top = this.setting.cursorAt.top;
			}
			else
			{
				var offset = this.item.eq(0).offset();
				this.cursor.left = event.pageX - offset.left;
				this.cursor.top = event.pageY - offset.top;
			}
		}
		
		this.mouseDrag(event);
		
		this.container
			.empty()
			.append(this.setting.helper(this.item))
			.show();
		
		this.callListener('start');
		
		return true;
	},
	
	mouseDrag: function(event)
	{
		this.position.x = event.pageX;
		this.position.y = event.pageY;
		
		if(this.setting.axis != 'y')
			this.container[0].style.left = (this.position.x - this.cursor.left) + 'px';
		if(this.setting.axis != 'x')
			this.container[0].style.top =  (this.position.y - this.cursor.top) + 'px';
		
		this.callListener('drag');
		
		return true;
	},
	
	mouseStop: function(event)
	{
		this.container.empty().hide();
		
		this.callListener('stop');
		this.cursor = null;
		
		return true;
	},
	
	getHandle: function(item)
	{
		return this.setting.handle ? item.find(this.setting.handle) : item;
	}
}));

// Cursor Listener
$.Interaction.listen('draggable',{
	start: function()
	{
		if(!this.setting.cursor)
			return;
		var body = $('body');
		this.temp.bodyCursor = body.css('cursor');
		body.css('cursor', this.setting.cursor);
		this.container.css('cursor', this.setting.cursor)
			.children().css('cursor', this.setting.cursor);
	},
	
	stop: function()
	{
		if(!this.setting.cursor)
			return;
		$('body').css('cursor', this.temp.bodyCursor);
	}
});

// Opacity Listener
$.Interaction.listen('draggable', {
	init: function()
	{
		if(this.setting.opacity)
			this.container.css('opacity', this.setting.opacity);
	}
})

// Scroll Defaults
$.Interaction.defaults('draggable', {
	scroll: true,
	scrollArea: 20,
	scrollSpeed: 20
});

// Scroll Listener
$.Interaction.listen('draggable', {
	start: function()
	{
		if(!this.setting.scroll)
			return;
		
		var self = this;
		this.scrollElement = this.element.chain('anchor');
		this.scrollOffset = this.scrollElement.offset();
		$.extend(this.scrollOffset, {
			scrollHeight:0, 
			scrollWidth:0, 
			height:this.scrollElement[0].offsetHeight,
			width:this.scrollElement[0].offsetWidth
		});
	
		this.scrollElement.children().each(function(){
			self.scrollOffset.scrollHeight += this.offsetHeight;
			self.scrollOffset.scrollWidth += this.offsetWidth;
		});
		
		this.temp.scrollInt = setInterval(function(){
			var el = self.scrollElement[0];
			var elOff = self.scrollOffset;
			var s = self.setting;
			var pos = self.position;
			var doc = $(document);
	
			if(elOff.scrollHeight > elOff.height && Math.abs(pos.y - elOff.top) < s.scrollArea)
				el.scrollTop -= s.scrollSpeed;
			if(elOff.scrollHeight > elOff.height && Math.abs(elOff.top + elOff.height - pos.y) < s.scrollArea)
				el.scrollTop += s.scrollSpeed;
	
			if(elOff.scrollWidth > elOff.width && Math.abs(pos.x - elOff.left) < s.scrollArea)
				el.scrollLeft -= s.scrollSpeed;
			if(elOff.scrollWidth > elOff.width && Math.abs(elOff.left + elOff.width - pos.x) < s.scrollArea)
				el.scrollLeft += s.scrollSpeed;
	
			if(pos.y - doc.scrollTop() < s.scrollArea)
				doc.scrollTop(doc.scrollTop() - s.scrollSpeed);
			if(window.innerHeight - (pos.y - doc.scrollTop()) < s.scrollArea)
				doc.scrollTop(doc.scrollTop() + s.scrollSpeed);
				
			if(pos.x - doc.scrollLeft() < s.scrollArea)
				doc.scrollLeft(doc.scrollLeft() - s.scrollSpeed);
			if(window.innerWidth - (pos.x - doc.scrollLeft()) < s.scrollArea)
				doc.scrollLeft(doc.scrollLeft() + s.scrollSpeed);
		}, 200);
	},
	
	stop: function()
	{
		if(!this.setting.scroll)
			return;
		
		clearInterval(this.temp.scrollInt);
	}
});

})(jQuery);


/* droppable.js */
(function($){

$.Interaction.ddmanager = ddmanager =
{
	droppables: [],
	draggable: null,
	status: '',
	
	getAllDroppables: function()
	{
		return $('.interaction-droppable').map(function(){return this.data('interaction-droppable')}).get();
	}
};

$.Interaction.add('droppable', {
	defaults:
	{
		accept: function(){return true;},
		classPrefix: 'drop-',
		activeClass: 'active',
		hoverClass: 'hover',
		dynamic: true,
		nested: false
	},
	
	init: function(setting)
	{
		this.base();
		this.setting = $.extend(this.setting, setting);
		this.draggable = null
		this.droppables = [];
		this.isOver = false;
		this.childOver = false;
		
		if(typeof this.setting.accept == 'string')
		{
			var className = this.setting.accept;
			this.setting.accept = function(element){return element.hasClass(className)};
		}
		
		this.extractListener('over', 'out', 'active', 'deactive', 'drop');
		this.updateParent();
		this.refreshOffset();
		this.callListener('init');
	},
	
	refreshOffset: function()
	{
		var element = this.element.get(0);
		var offset = this.element.offset();
		
		this.offset =
		{
			width: element.offsetWidth,
			height: element.offsetHeight,
			top: offset.top,
			left: offset.left
		};
	},
	
	intersect: function(draggable)
	{
		if(this.setting.dynamic)
			this.refreshOffset();
		
		return draggable.position.x >= this.offset.left
			&& draggable.position.y >= this.offset.top
			&& draggable.position.x <= this.offset.left + this.offset.width
			&& draggable.position.y <= this.offset.top + this.offset.height;
	},
	
	updateParent: function()
	{
		var oldparent = this.parent || ddmanager;
		
		var parent = this.element.parents('.interaction-droppable');
		this.parent = parent.length ? parent.data('interaction-droppable') : false;
		
		if(this.parent != oldparent)
		{
			var droppables = [];
			for(var i=0; i<oldparent.droppables.length; i++)
				if(oldparent.droppables[i] != this)
					droppables.push(oldparent.droppables[i]);
			
			oldparent.droppables = droppables;
			
			(this.parent || ddmanager).droppables.push(this);
		}
	},
	
	setStatus: function(stat)
	{
		ddmanager.status = stat;
	},
	
	mouseStart: function()
	{
		if(!this.isEnabled) return;
		
		this.updateParent();
		
		this.draggable = ddmanager.draggable;
		
		if(this.draggable.element != this.element && this.setting.accept(this.draggable.element, this.draggable.item))
		{
			this.isActive = true;
			this.dragActive();
		}
		
		$.each(this.droppables, function(){
			this.mouseStart();
		});
	},
	
	mouseDrag: function()
	{
		var intersect = false;
		
		if(this.isEnabled && this.isActive)
		{
			intersect = this.intersect(this.draggable);
			if((!intersect || (intersect && this.childOver)) && this.isOver)
			{
				this.dragOut();
				this.isOver = false;
				if(this.parent && this.setting.nested && !this.childOver)
					this.parent.childOver = false;
			}
			else if(!this.isOver && intersect && !this.childOver)
			{
				this.dragOver();
				this.isOver = true;
				if(this.parent && this.setting.nested)
					this.parent.childOver = true;
			}
		}
		
		$.each(this.droppables, function(){
			if(!this.setting.nested || (this.setting.nested && intersect))
				this.mouseDrag();
		});
	},
	
	mouseStop: function()
	{
		var intersect = this.intersect(this.draggable);
		if(this.isActive && intersect && !this.childOver)
			this.dragDrop();
		
		this.dragDeactive();
		
		this.draggable = null;
		this.isActive = false;
		this.isOver = false;
		this.childOver = false;
		
		$.each(this.droppables, function(){
			this.mouseStop();
		});
	},
	
	dragActive: function()
	{
		this.callListener('active', this.draggable.item);
	},
	
	dragDeactive: function()
	{
		this.callListener('deactive', this.draggable.item);
	},
	
	dragOver: function()
	{
		this.callListener('over', this.draggable.item);
	},
	
	dragOut: function()
	{
		this.callListener('out', this.draggable.item);
	},
	
	dragDrop: function()
	{
		this.callListener('drop', this.draggable.item);
	}
});

// Track Draggable
$.Interaction.listen('draggable', {
	start: function()
	{
		ddmanager.draggable = this;
		$.each(ddmanager.droppables, function(){
			this.mouseStart();
		})
	},
	
	drag: function()
	{
		if(ddmanager.status != this.lastDragStatus)
		{
			this.container.removeClass(this.setting.classPrefix+this.lastDragStatus);
			this.container.addClass(this.setting.classPrefix+ddmanager.status);
			this.lastDragStatus = ddmanager.status;
		}
		
		$.each(ddmanager.droppables, function(){
			this.mouseDrag();
		})
	},
	
	stop: function()
	{
		$.each(ddmanager.droppables, function()
		{
			this.mouseStop();
		});
		
		ddmanager.draggable = null;
		ddmanager.status = '';
	}
});

// Class Tracker
$.Interaction.listen('droppable', {
	active: function()
	{
		this.element.addClass(this.setting.classPrefix+this.setting.activeClass);
	},
	
	deactive: function()
	{
		this.element.removeClass(this.setting.classPrefix+this.setting.activeClass);
		this.element.removeClass(this.setting.classPrefix+this.setting.hoverClass);
	},
	
	over: function()
	{
		this.element.addClass(this.setting.classPrefix+this.setting.hoverClass);
	},
	
	out: function()
	{
		this.element.removeClass(this.setting.classPrefix+this.setting.hoverClass);
	}
});

})(jQuery);


/* sortable.js */
(function($){

$.Interaction.add('sortable', {
	defaults:
	{
		marker: 'transparent',
		boundary: 6,
		align: 'vertical',
		accept: false,
		transfer: 'move'
	},
	
	init: function(setting)
	{
		this.base();
		$.extend(this.setting, setting);
		
		this.parseMarker();
		
		if(!this.element.data('interaction-draggable'))
			this.element.draggable({
				start: this.wrap('mouseStart'),
				drag: this.wrap('mouseDrag'),
				stop: this.wrap('mouseStop')
			});
		else
			this.element.draggable('listen', {
				start: this.wrap('mouseStart'),
				drag: this.wrap('mouseDrag'),
				stop: this.wrap('mouseStop')
			});
		
		if(this.setting.accept)
		{
			if(typeof this.setting.accept == 'string')
			{
				var className = this.setting.accept;
				this.setting.accept = function(element){return element.hasClass(className)};
			}
			
			if(!this.element.data('interaction-droppable'))
				this.element.droppable({
					over: this.wrap('dragOver')
				});
			else
				this.element.droppable('listen', {
					over: this.wrap('dragOver')
				});
			
			this.element.data('interaction-droppable').setting.dynamic = true;
		}
		
		this.draggable = this.element.data('interaction-draggable');
		
		this.extractListener('reorder');
		
		this.currentIndex = -1;
		this.lastIndex = -1;
		this.isActive = false;
		
		this.callListener('init');
	},
	
	parseMarker: function()
	{
		if(typeof this.setting.marker == 'function')
			return;
		
		var marker = this.setting.marker;
		
		if(marker == 'transparent')
			marker = function(item){
				return item.eq(0).clone().css('visibility', 'hidden');
			};
		else if(marker == 'separator')
			marker = function(item, align){
				return $('<div></div>')
					.css('overflow', 'hidden')
					.addClass('interaction-sortable-separator')[(align == 'vertical' ? 'height' : 'width')](0);
			};
		else
			marker = function(item){
				return item.clone();
			}
		
		this.setting.marker = marker;
	},
	
	mouseStart: function()
	{
		this.isActive = true;
		this.item = this.draggable.item;
		this.marker = this.setting.marker(this.item, this.setting.align);
		this.marker.removeClass('chain-item').addClass('interaction-sortable-marker');
		this.item.eq(0).before(this.marker);
		this.item.hide();
		this.currentIndex = this.marker.parent().children(':visible').index(this.marker);
		this.lastIndex = this.currentIndex;
	},
	
	mouseDrag: function()
	{
		if(this.item)
		{	
			var pos = this.draggable.position;
			var setting = this.setting;
			var item = this.item;
			var marker = this.marker;
			var self = this;
			
			var offset = this.element.offset();
			offset.height = this.element[0].offsetHeight;
			offset.width = this.element[0].offsetWidth;
			
			if(pos.y < offset.top || pos.y > (offset.top + offset.height)
				|| pos.x < offset.left || pos.x > (offset.left + offset.width))
			{
				item.eq(0).before(marker);
				return;
			}
			
			var items = this.element.items();
			var markerIndex = marker.parent().children(':visible').index(marker);
			
			for(var i=0; i<items.length; i++)
			{
				var hover = $(items[i]);
				var offset = hover.offset();
				
				offset.height = hover[0].offsetHeight;
				offset.width = hover[0].offsetWidth;
				
				if(setting.align == 'vertical')
				{ var xy = 'y';var tl = 'top';var hw = 'height'; }
				else
				{ var xy = 'x';var tl = 'left';var hw = 'width'; }
				
				self.currentIndex = markerIndex;
				var moved = self.currentIndex != self.lastIndex;
			
				if(hover.prev()[0] != marker[marker.length-1]
					&& pos[xy] - offset[tl] > 0 && pos[xy] - offset[tl] < setting.boundary)
					hover.before(marker);
				else if(hover.next()[0] != marker[0]
					&& offset[tl] + offset[hw] - pos[xy] > 0 && offset[tl] + offset[hw] - pos[xy] < setting.boundary)
					hover.after(marker);
				
				if(moved)
				{
					self.callListener('reorder');
					self.lastIndex = self.currentIndex;
					break;
				}
			}
			this.element.items().each(function(){
				
			});
		}
	},
	
	mouseStop: function()
	{
		if(this.item && $.Chain.jidentic(this.item.item('root'), this.element))
		{
			this.marker.before(this.item);
			this.item.show();
		}
		this.marker.remove();
		
		
		this.isActive = false;
		this.item = null;
		this.marker = null;
		this.element.update();
	},
	
	dragOver: function(droppable, item)
	{
		if(item.item('root') == this.element)
			return;
		
		var sortable = item.item('root').data('interaction-sortable');
		
		if(this.setting.accept(sortable.element, item))
		{
			var cursor = sortable.draggable.cursor;
			
			var newItem = $().eq(-1);
			var data = item.map(function(){return $(this).item();}).get();
			this.element.items('merge', data);
			for(var i=0; i<data.length; i++)
				newItem = newItem.add(this.element.items(data[i]));
			
			if(sortable.setting.transfer == 'move')
				item.remove();
				
			sortable.draggable.mouseUp(sortable.draggable.mouseDownEvent);
			this.draggable.item = newItem;
			this.draggable.cursor = cursor;
			this.draggable.mouseDown(sortable.draggable.mouseMoveEvent);
		}
	},
	
	$destroy: function()
	{
		this.element.draggable('unlisten', 'start', this.wrap('mouseStart'));
		this.element.draggable('unlisten', 'drag', this.wrap('mouseDrag'));
		this.element.draggable('unlisten', 'stop', this.wrap('mouseStop'));
	}
});

})(jQuery);


/* selectable.js */
(function($){

$.Interaction.add('selectable', {
	defaults:
	{
		multiple: false,
		required: false,
		selected: null,
		selectClass: 'selected',
		drag: false
	},
	
	init: function(setting)
	{
		this.base();
		$.extend(this.setting, setting);
		
		this.selected = this.setting.selected ? $(this.setting.selected) : $().eq(-1);
		
		this.extractListener('select', 'unselect', 'change');
		this.callListener('init');
	},
	
	builder: function(item)
	{
		var self = this;
		item
			.bind('mousedown.selectable-item', function(event){
				if(self.isEnabled)
					self.mouseDown(event, item);
			})
			.bind('click.selectable-item', function(event){
				if(self.isEnabled)
					return self.mouseClick(event, item);
			});
		
		if(this.setting.required && !this.selected.length && item.parent().children(':visible').index(item) == 0)
			this.select(item);
		else if(this.selected.index(item) > -1)
			this.select(item);
	},
	
	mouseDown: function(event, item)
	{
		this.mouseDownEvent = event;
		var draggable = this.element.draggable('service');
		if(draggable && this.$selected(item) && this.setting.drag)
		{
			draggable.mouseUp(draggable.mouseDownEvent);
			draggable.item = this.selected.filter(':visible');
			draggable.mouseDown(event);
		}
	},
	
	mouseClick: function(event, item)
	{
		if($.browser.msie && this.mouseDownEvent);
			event = this.mouseDownEvent;
		
		if(event.which != 1)
			alert(event.which);
		
		if(event.metaKey)
		{
			if(this.$selected(item) && (!this.setting.required || this.selected.length > 1))
				this.$unselect(item);
			else
				this.$select(item);	
		}
		else if(event.shiftKey)
		{
			var selected = this.selected.eq(0);
			
			if(selected.length && !$.Chain.jidentic(item, selected))
			{
				var items = selected.parent().children(':visible');
				var dir = items.index(selected) < items.index(item) ? 'next' : 'prev';
				var next = selected[dir]();
				while(next.length)
				{
					selected = selected.add(next);
					if($.Chain.jidentic(next, item))
						break;
					next = next[dir]();
				}
			}
			
			this.clear();
			this.$select(selected.length ? selected : item);
		}
		else
		{
			this.clear();
			this.$select(item);
		}
	},
	
	select: function()
	{
		var args = Array.prototype.slice.call(arguments);
		var self = this;
		
		this.selected.removeClass(this.setting.selectClass);
		
		$.each(args, function(){
			if(this && typeof this != 'boolean')
				self.selected = self.selected.add(self.element.items(this));
		});
		
		this.selected = this.selected.filter(function(){
			var root = $(this).item('root');
			return this && root && root[0] == self.element[0];
		});
		
		if(!this.setting.multiple)
			this.selected = this.selected.eq(this.selected.length - 1);
		
		this.selected.addClass(this.setting.selectClass);
	},
	
	unselect: function()
	{
		var args = Array.prototype.slice.call(arguments);
		var self = this;
		
		this.selected.removeClass(this.setting.selectClass);
		
		$.each(args, function(){
			if(this && typeof this != 'boolean')
				self.selected = self.selected.not(self.element.items(this));
		});
		
		this.selected.addClass(this.setting.selectClass);
	},
	
	clear: function()
	{
		this.selected.removeClass(this.setting.selectClass);
		this.selected = $().eq(1);
	},
	
	$select: function()
	{
		if(!this.isEnabled) return this.element;
		
		this.select.apply(this, Array.prototype.slice.call(arguments));
		
		this.callListener('select');
		this.callListener('change');
		
		return this.element;
	},
	
	$unselect: function()
	{
		if(!this.isEnabled) return this.element;
		
		this.unselect.apply(this, Array.prototype.slice.call(arguments));
		
		this.callListener('unselect');
		this.callListener('change');
		
		return this.element;
	},
	
	$clear: function()
	{
		if(!this.isEnabled) return this.element;
		
		this.clear();
		
		this.callListener('unselect');
		this.callListener('change');
		
		return this.element;
	},
	
	$selected: function(item)
	{
		if(!this.isEnabled) return $().eq(-1);
		
		if(item === true)
			return this.selected;
		else if(arguments.length && typeof item != 'boolean' && item !== null)
			return this.selected.index(this.element.items(item)) > -1;
		else
			return this.selected.filter(':visible');
	}
});

// Update element on selection change
$.Interaction.listen('selectable',{
	change: function()
	{
		this.element.update();
	}
});

})(jQuery);

